module std.logger.templatelogger;

public import std.logger.core;
import std.functional : unaryFun;
import std.string;
import std.format;
import std.array;
import std.range;

/** This function will create a log message in the default way used in the
$(D std.logger).
*/
public void defaultFormatter(T,F)(ref T t, ref F payload) @trusted
{
    size_t fnIdx = payload.file.lastIndexOf('/') + 1;
    size_t funIdx = payload.funcName.lastIndexOf('.') + 1;
    formattedWrite(t, "%s:%s:%s:%u %s\n",payload.timestamp.toISOExtString(),
        payload.file[fnIdx .. $], payload.funcName[funIdx .. $],
        payload.line, payload.msg);
}

/** The $(D TemplateLogger) is an easy way to build custom logger.

The $(D TemplateLogger) takes a Sink a Formatter and a Filter. The Filter
takes a $(D Logger.LoggerPayload) as a parameter and returns $(D true) if the
message is supposed to be logged. The Formatter takes an $(D OutputRange) and
a $(D Logger.LoggerPayload) as a parameter and processes it depending on its
implementation. The Sink will present the log message generated by the
Formatter.
*/
class TemplateLogger(Sink, alias Formatter, alias Filter) : Logger
{
    protected Sink sink;
    private alias filterFun = unaryFun!Filter;

    /** A constructor for the TemplateLogger.

    Params:
        sink = The Sink used to pass the output of the Formatter to.
        lv = The $(D LogLevel) used by the logger.
    */
    public this(Sink sink, const LogLevel lv = LogLevel.info)
    {
        this(sink, "", lv);
    }

    /** A constructor for the TemplateLogger.

    Params:
        sink = The Sink used to pass the output of the Formatter to.
        name = The name of the $(D Logger).
        lv = The $(D LogLevel) used by the logger.
    */
    public this(Sink sink, string name, const LogLevel lv = LogLevel.info)
    {
        super(name, lv);
        this.sink = sink;
    }

    public override void writeLogMsg(ref LoggerPayload payload)
    {
        version(DisableTemplateLogging)
        {
        }
        else
        {
            if (filterFun(payload))
            {
                Formatter(this.sink, payload);
            }
        }
    }
}

unittest
{
    import std.conv;
    auto app = appender!string();

    alias defaultF = defaultFormatter!(Appender!string, Logger.LoggerPayload);
    auto l = new TemplateLogger!(Appender!string, defaultF,
        (a) => true)(app);
    l.log("Hello");
    int line = __LINE__ - 1;

    assert(app.data().indexOf("Hello") != -1);
    assert(app.data().indexOf(to!string(line)) != line);
}
